type Activity {
  id: ID!
  ActivityType: ActivityType!
  title: String!
  date: DateTime
  user: User!
  distance: Float!
  distance_unit: Unit!
  duration: Float!
  elevation: Float
  elevation_unit: Unit
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivityConnection {
  pageInfo: PageInfo!
  edges: [ActivityEdge]!
  aggregate: AggregateActivity!
}

input ActivityCreateInput {
  id: ID
  ActivityType: ActivityType!
  title: String!
  date: DateTime
  user: UserCreateOneInput!
  distance: Float!
  distance_unit: Unit!
  duration: Float!
  elevation: Float
  elevation_unit: Unit
}

type ActivityEdge {
  node: Activity!
  cursor: String!
}

enum ActivityOrderByInput {
  id_ASC
  id_DESC
  ActivityType_ASC
  ActivityType_DESC
  title_ASC
  title_DESC
  date_ASC
  date_DESC
  distance_ASC
  distance_DESC
  distance_unit_ASC
  distance_unit_DESC
  duration_ASC
  duration_DESC
  elevation_ASC
  elevation_DESC
  elevation_unit_ASC
  elevation_unit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ActivityPreviousValues {
  id: ID!
  ActivityType: ActivityType!
  title: String!
  date: DateTime
  distance: Float!
  distance_unit: Unit!
  duration: Float!
  elevation: Float
  elevation_unit: Unit
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActivitySubscriptionPayload {
  mutation: MutationType!
  node: Activity
  updatedFields: [String!]
  previousValues: ActivityPreviousValues
}

input ActivitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActivityWhereInput
  AND: [ActivitySubscriptionWhereInput!]
  OR: [ActivitySubscriptionWhereInput!]
  NOT: [ActivitySubscriptionWhereInput!]
}

enum ActivityType {
  CYCLING
  RUNNING
}

input ActivityUpdateInput {
  ActivityType: ActivityType
  title: String
  date: DateTime
  user: UserUpdateOneRequiredInput
  distance: Float
  distance_unit: Unit
  duration: Float
  elevation: Float
  elevation_unit: Unit
}

input ActivityUpdateManyMutationInput {
  ActivityType: ActivityType
  title: String
  date: DateTime
  distance: Float
  distance_unit: Unit
  duration: Float
  elevation: Float
  elevation_unit: Unit
}

input ActivityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  ActivityType: ActivityType
  ActivityType_not: ActivityType
  ActivityType_in: [ActivityType!]
  ActivityType_not_in: [ActivityType!]
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  user: UserWhereInput
  distance: Float
  distance_not: Float
  distance_in: [Float!]
  distance_not_in: [Float!]
  distance_lt: Float
  distance_lte: Float
  distance_gt: Float
  distance_gte: Float
  distance_unit: Unit
  distance_unit_not: Unit
  distance_unit_in: [Unit!]
  distance_unit_not_in: [Unit!]
  duration: Float
  duration_not: Float
  duration_in: [Float!]
  duration_not_in: [Float!]
  duration_lt: Float
  duration_lte: Float
  duration_gt: Float
  duration_gte: Float
  elevation: Float
  elevation_not: Float
  elevation_in: [Float!]
  elevation_not_in: [Float!]
  elevation_lt: Float
  elevation_lte: Float
  elevation_gt: Float
  elevation_gte: Float
  elevation_unit: Unit
  elevation_unit_not: Unit
  elevation_unit_in: [Unit!]
  elevation_unit_not_in: [Unit!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ActivityWhereInput!]
  OR: [ActivityWhereInput!]
  NOT: [ActivityWhereInput!]
}

input ActivityWhereUniqueInput {
  id: ID
}

type AggregateActivity {
  count: Int!
}

type AggregateClub {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Club {
  id: ID!
  name: String!
  email: String!
  address: String
}

type ClubConnection {
  pageInfo: PageInfo!
  edges: [ClubEdge]!
  aggregate: AggregateClub!
}

input ClubCreateInput {
  id: ID
  name: String!
  email: String!
  address: String
}

input ClubCreateOneInput {
  create: ClubCreateInput
  connect: ClubWhereUniqueInput
}

type ClubEdge {
  node: Club!
  cursor: String!
}

enum ClubOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  address_ASC
  address_DESC
}

type ClubPreviousValues {
  id: ID!
  name: String!
  email: String!
  address: String
}

type ClubSubscriptionPayload {
  mutation: MutationType!
  node: Club
  updatedFields: [String!]
  previousValues: ClubPreviousValues
}

input ClubSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClubWhereInput
  AND: [ClubSubscriptionWhereInput!]
  OR: [ClubSubscriptionWhereInput!]
  NOT: [ClubSubscriptionWhereInput!]
}

input ClubUpdateDataInput {
  name: String
  email: String
  address: String
}

input ClubUpdateInput {
  name: String
  email: String
  address: String
}

input ClubUpdateManyMutationInput {
  name: String
  email: String
  address: String
}

input ClubUpdateOneInput {
  create: ClubCreateInput
  update: ClubUpdateDataInput
  upsert: ClubUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ClubWhereUniqueInput
}

input ClubUpsertNestedInput {
  update: ClubUpdateDataInput!
  create: ClubCreateInput!
}

input ClubWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  AND: [ClubWhereInput!]
  OR: [ClubWhereInput!]
  NOT: [ClubWhereInput!]
}

input ClubWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type Mutation {
  createActivity(data: ActivityCreateInput!): Activity!
  updateActivity(data: ActivityUpdateInput!, where: ActivityWhereUniqueInput!): Activity
  updateManyActivities(data: ActivityUpdateManyMutationInput!, where: ActivityWhereInput): BatchPayload!
  upsertActivity(where: ActivityWhereUniqueInput!, create: ActivityCreateInput!, update: ActivityUpdateInput!): Activity!
  deleteActivity(where: ActivityWhereUniqueInput!): Activity
  deleteManyActivities(where: ActivityWhereInput): BatchPayload!
  createClub(data: ClubCreateInput!): Club!
  updateClub(data: ClubUpdateInput!, where: ClubWhereUniqueInput!): Club
  updateManyClubs(data: ClubUpdateManyMutationInput!, where: ClubWhereInput): BatchPayload!
  upsertClub(where: ClubWhereUniqueInput!, create: ClubCreateInput!, update: ClubUpdateInput!): Club!
  deleteClub(where: ClubWhereUniqueInput!): Club
  deleteManyClubs(where: ClubWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permission {
  ADMIN
  CLUB_ADMIN
  USER
  FRIEND
}

type Query {
  activity(where: ActivityWhereUniqueInput!): Activity
  activities(where: ActivityWhereInput, orderBy: ActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Activity]!
  activitiesConnection(where: ActivityWhereInput, orderBy: ActivityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActivityConnection!
  club(where: ClubWhereUniqueInput!): Club
  clubs(where: ClubWhereInput, orderBy: ClubOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Club]!
  clubsConnection(where: ClubWhereInput, orderBy: ClubOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClubConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  activity(where: ActivitySubscriptionWhereInput): ActivitySubscriptionPayload
  club(where: ClubSubscriptionWhereInput): ClubSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

enum Unit {
  MILES
  KM
  FEET
  METERS
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  club: Club
  permissions: [Permission!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  club: ClubCreateOneInput
  permissions: UserCreatepermissionsInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permission!]
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  permissions: [Permission!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  club: ClubUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  club: ClubUpdateOneInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  permissions: UserUpdatepermissionsInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permission!]
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  club: ClubWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
